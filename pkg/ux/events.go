// Copyright (C) 2025 Aleutian AI (jinterlante@aleutian.ai)
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// See the LICENSE.txt file for the full license text.
//
// NOTE: This work is subject to additional terms under AGPL v3 Section 7.
// See the NOTICE.txt file for details regarding AI system attribution.

// Package ux provides user experience components for the Aleutian CLI.
//
// This file defines the core event types for streaming LLM responses.
// These types form the foundation of the streaming architecture:
//
//	Parser → Reader → Renderer
//	  ↓        ↓         ↓
//	bytes → events → output
//
// All types in this file are immutable value types with no methods.
// They are designed to be passed by value through channels and callbacks.
//
// Tracing Convention:
//
// All significant types include Id and CreatedAt fields following the
// orchestrator's datatypes package patterns. This enables:
//   - Request/response correlation across services
//   - Audit logging with timestamps
//   - Debugging with unique identifiers
package ux

import (
	"time"

	"github.com/google/uuid"
)

// =============================================================================
// Stream Event Types
// =============================================================================

// StreamEventType categorizes streaming events from LLM responses.
//
// Events flow through the streaming pipeline in a defined order:
//
//  1. StatusEvent(s) - Optional progress updates ("Searching...", "Generating...")
//  2. SourcesEvent - Optional retrieved sources (RAG only, may arrive before or during tokens)
//  3. ThinkingEvent(s) - Optional reasoning tokens (Claude extended thinking)
//  4. TokenEvent(s) - The actual response tokens
//  5. DoneEvent or ErrorEvent - Terminal event, exactly one must occur
//
// Example event sequence for RAG chat:
//
//	status:"Retrieving documents..." → sources:[doc1,doc2] → token:"The" → token:" answer" → done
type StreamEventType string

const (
	// StreamEventStatus indicates a progress update.
	//
	// These events provide user feedback during long operations.
	// Renderers typically display these as spinner messages.
	//
	// Example payload: {"type":"status","message":"Searching knowledge base..."}
	StreamEventStatus StreamEventType = "status"

	// StreamEventToken indicates a response token from the LLM.
	//
	// Tokens arrive incrementally as the model generates its response.
	// Renderers typically print these immediately for a streaming effect.
	//
	// Example payload: {"type":"token","content":"Hello"}
	StreamEventToken StreamEventType = "token"

	// StreamEventThinking indicates reasoning/thinking tokens.
	//
	// These are generated by Claude's extended thinking feature.
	// Renderers may display these differently (muted, collapsible, or hidden).
	//
	// Example payload: {"type":"thinking","content":"Let me analyze this..."}
	StreamEventThinking StreamEventType = "thinking"

	// StreamEventSources indicates retrieved knowledge base sources.
	//
	// Only present in RAG responses. May arrive before, during, or after tokens.
	// Renderers should display these inline as they arrive.
	//
	// Example payload: {"type":"sources","sources":[{"source":"doc.pdf","score":0.95}]}
	StreamEventSources StreamEventType = "sources"

	// StreamEventDone indicates successful stream completion.
	//
	// This is a terminal event - no more events will follow.
	// Contains the final session ID for multi-turn conversations.
	//
	// Example payload: {"type":"done","session_id":"sess-abc123"}
	StreamEventDone StreamEventType = "done"

	// StreamEventError indicates an error during streaming.
	//
	// This is a terminal event - no more events will follow.
	// The stream should be considered failed after this event.
	//
	// Example payload: {"type":"error","error":"Model overloaded, please retry"}
	StreamEventError StreamEventType = "error"
)

// String returns the string representation of the event type.
func (t StreamEventType) String() string {
	return string(t)
}

// IsTerminal returns true if this event type ends the stream.
//
// After a terminal event (Done or Error), no more events will arrive.
// Callers should stop reading and finalize rendering.
func (t StreamEventType) IsTerminal() bool {
	return t == StreamEventDone || t == StreamEventError
}

// =============================================================================
// Stream Event
// =============================================================================

// StreamEvent represents a single event from a streaming LLM response.
//
// This is an immutable value type designed to flow through the streaming
// pipeline. Each event carries exactly one piece of information; the Type
// field determines which content field is populated.
//
// Field population by Type:
//
//	Type=status:   Message is set
//	Type=token:    Content is set
//	Type=thinking: Content is set
//	Type=sources:  Sources is set
//	Type=done:     SessionID is set (may be empty)
//	Type=error:    Error is set
//
// Tracing:
//
//	Every event has an Id (UUID) and CreatedAt timestamp for tracing.
//	The Id is generated when the event is created (by parser or constructor).
//	CreatedAt is the local timestamp when the event was created.
//
// Example:
//
//	event := StreamEvent{
//	    Id:        uuid.New().String(),
//	    CreatedAt: time.Now().UnixMilli(),
//	    Type:      StreamEventToken,
//	    Content:   "Hello",
//	}
type StreamEvent struct {
	// Id is the unique identifier for this event.
	// Generated by the parser or constructor, used for tracing.
	Id string `json:"id"`

	// CreatedAt is the Unix timestamp (milliseconds) when this event was created.
	// This is the local time when the client parsed/created the event.
	CreatedAt int64 `json:"created_at"`

	// Type categorizes this event.
	// This field is always set and determines which other fields are valid.
	Type StreamEventType `json:"type"`

	// Index is the zero-based position of this event in the stream.
	// Set by the StreamReader as events are processed.
	Index int `json:"index"`

	// Content holds token or thinking text.
	// Set when Type is StreamEventToken or StreamEventThinking.
	Content string `json:"content,omitempty"`

	// Message holds status update text.
	// Set when Type is StreamEventStatus.
	Message string `json:"message,omitempty"`

	// Sources holds retrieved knowledge base sources.
	// Set when Type is StreamEventSources.
	Sources []SourceInfo `json:"sources,omitempty"`

	// SessionID holds the conversation session identifier.
	// Set when Type is StreamEventDone.
	SessionID string `json:"session_id,omitempty"`

	// Error holds the error message.
	// Set when Type is StreamEventError.
	Error string `json:"error,omitempty"`

	// RequestID correlates this event with the originating request.
	// May be set by the server or propagated from the request.
	RequestID string `json:"request_id,omitempty"`

	// Hash is the SHA-256 hash of this event for tamper-evident logging.
	// Formula: SHA256(Content || CreatedAt || PrevHash)
	Hash string `json:"hash,omitempty"`

	// PrevHash is the hash of the previous event in the chain.
	// First event has empty PrevHash; subsequent events chain to previous.
	PrevHash string `json:"prev_hash,omitempty"`
}

// IsTerminal returns true if this event ends the stream.
func (e StreamEvent) IsTerminal() bool {
	return e.Type.IsTerminal()
}

// CreatedAtTime returns CreatedAt as a time.Time value.
func (e StreamEvent) CreatedAtTime() time.Time {
	return time.UnixMilli(e.CreatedAt)
}

// =============================================================================
// Stream Result
// =============================================================================

// StreamResult contains the aggregated result after stream completion.
//
// This struct accumulates all events from a streaming response into a
// single result object. It's populated by StreamReader.ReadAll() or by
// a StreamRenderer after processing all events.
//
// Tracing:
//
//	Id is a unique identifier for this result (UUID).
//	CreatedAt is when aggregation began (first event received).
//	CompletedAt is when the stream ended (done/error event).
//
// Example:
//
//	result := StreamResult{
//	    Id:        uuid.New().String(),
//	    CreatedAt: startTime.UnixMilli(),
//	    Answer:    "The capital of France is Paris.",
//	    Sources:   []SourceInfo{{Source: "geography.pdf", Score: 0.95}},
//	    SessionID: "sess-abc123",
//	}
type StreamResult struct {
	// Id is the unique identifier for this result.
	Id string `json:"id"`

	// CreatedAt is the Unix timestamp (milliseconds) when streaming began.
	CreatedAt int64 `json:"created_at"`

	// CompletedAt is the Unix timestamp (milliseconds) when streaming ended.
	CompletedAt int64 `json:"completed_at"`

	// RequestID correlates this result with the originating request.
	RequestID string `json:"request_id,omitempty"`

	// Answer is the complete response text (all tokens concatenated).
	Answer string `json:"answer"`

	// Thinking is the complete thinking/reasoning text (Claude extended thinking).
	// May be empty if thinking was not enabled or not generated.
	Thinking string `json:"thinking,omitempty"`

	// Sources is the list of retrieved knowledge base sources.
	// Empty for non-RAG responses.
	Sources []SourceInfo `json:"sources,omitempty"`

	// SessionID is the conversation session identifier.
	// Used for multi-turn conversation continuity.
	SessionID string `json:"session_id,omitempty"`

	// Error is set if the stream ended with an error event.
	// If non-empty, Answer may be incomplete or empty.
	Error string `json:"error,omitempty"`

	// TotalTokens is the number of token events received.
	TotalTokens int `json:"total_tokens"`

	// ThinkingTokens is the number of thinking token events received.
	ThinkingTokens int `json:"thinking_tokens"`

	// TotalEvents is the total number of events received.
	TotalEvents int `json:"total_events"`

	// ModelID identifies which model generated the response.
	ModelID string `json:"model_id,omitempty"`

	// FirstTokenAt is when the first token event arrived (Unix ms).
	FirstTokenAt int64 `json:"first_token_at,omitempty"`

	// ChainHash is the final hash of the event chain.
	// This is the Hash from the last (done/error) event.
	// Used to verify the complete stream integrity.
	ChainHash string `json:"chain_hash,omitempty"`

	// ContentHash is SHA-256 hash of the accumulated answer content.
	// Used for content integrity verification separate from the chain.
	ContentHash string `json:"content_hash,omitempty"`
}

// HasError returns true if the stream ended with an error.
func (r StreamResult) HasError() bool {
	return r.Error != ""
}

// CreatedAtTime returns CreatedAt as a time.Time value.
func (r StreamResult) CreatedAtTime() time.Time {
	return time.UnixMilli(r.CreatedAt)
}

// CompletedAtTime returns CompletedAt as a time.Time value.
func (r StreamResult) CompletedAtTime() time.Time {
	return time.UnixMilli(r.CompletedAt)
}

// FirstTokenAtTime returns FirstTokenAt as a time.Time value.
func (r StreamResult) FirstTokenAtTime() time.Time {
	if r.FirstTokenAt == 0 {
		return time.Time{}
	}
	return time.UnixMilli(r.FirstTokenAt)
}

// Duration returns the total streaming duration.
func (r StreamResult) Duration() time.Duration {
	if r.CompletedAt == 0 || r.CreatedAt == 0 {
		return 0
	}
	return time.Duration(r.CompletedAt-r.CreatedAt) * time.Millisecond
}

// TimeToFirstToken returns the duration from stream start to first token.
//
// Returns zero if no tokens were received or timing data is unavailable.
func (r StreamResult) TimeToFirstToken() time.Duration {
	if r.FirstTokenAt == 0 || r.CreatedAt == 0 {
		return 0
	}
	return time.Duration(r.FirstTokenAt-r.CreatedAt) * time.Millisecond
}

// TokensPerSecond returns the average token generation rate.
//
// Returns zero if no tokens were received or timing data is unavailable.
func (r StreamResult) TokensPerSecond() float64 {
	duration := r.Duration()
	if r.TotalTokens == 0 || duration == 0 {
		return 0
	}
	return float64(r.TotalTokens) / duration.Seconds()
}

// =============================================================================
// Stream Callback
// =============================================================================

// StreamCallback is invoked for each streaming event.
//
// Implementations should be fast and non-blocking. If processing takes
// significant time, consider buffering events in a channel.
//
// Return nil to continue processing. Return an error to stop the stream
// early; the error will be propagated to the StreamReader caller.
//
// Example:
//
//	callback := func(event StreamEvent) error {
//	    switch event.Type {
//	    case StreamEventToken:
//	        fmt.Print(event.Content)
//	    case StreamEventError:
//	        return errors.New(event.Error)
//	    }
//	    return nil
//	}
type StreamCallback func(event StreamEvent) error

// =============================================================================
// Constructor Functions
// =============================================================================

// newEventBase creates the base fields for a new event.
func newEventBase(eventType StreamEventType) StreamEvent {
	return StreamEvent{
		Id:        uuid.New().String(),
		CreatedAt: time.Now().UnixMilli(),
		Type:      eventType,
	}
}

// NewTokenEvent creates a token event with the given content.
//
// Automatically generates Id and sets CreatedAt to current time.
func NewTokenEvent(content string) StreamEvent {
	event := newEventBase(StreamEventToken)
	event.Content = content
	return event
}

// NewThinkingEvent creates a thinking event with the given content.
//
// Automatically generates Id and sets CreatedAt to current time.
func NewThinkingEvent(content string) StreamEvent {
	event := newEventBase(StreamEventThinking)
	event.Content = content
	return event
}

// NewStatusEvent creates a status event with the given message.
//
// Automatically generates Id and sets CreatedAt to current time.
func NewStatusEvent(message string) StreamEvent {
	event := newEventBase(StreamEventStatus)
	event.Message = message
	return event
}

// NewSourcesEvent creates a sources event with the given sources.
//
// Automatically generates Id and sets CreatedAt to current time.
func NewSourcesEvent(sources []SourceInfo) StreamEvent {
	event := newEventBase(StreamEventSources)
	event.Sources = sources
	return event
}

// NewDoneEvent creates a done event with the given session ID.
//
// Automatically generates Id and sets CreatedAt to current time.
func NewDoneEvent(sessionID string) StreamEvent {
	event := newEventBase(StreamEventDone)
	event.SessionID = sessionID
	return event
}

// NewErrorEvent creates an error event with the given error message.
//
// Automatically generates Id and sets CreatedAt to current time.
func NewErrorEvent(errMsg string) StreamEvent {
	event := newEventBase(StreamEventError)
	event.Error = errMsg
	return event
}

// NewStreamResult creates a new StreamResult with Id and CreatedAt set.
//
// Call this at the start of streaming to initialize the result.
// Update fields as events arrive, then set CompletedAt when done.
func NewStreamResult() *StreamResult {
	return &StreamResult{
		Id:        uuid.New().String(),
		CreatedAt: time.Now().UnixMilli(),
	}
}

// NewStreamResultWithRequestID creates a new StreamResult with a request ID.
//
// Use this when you have a request ID to correlate with server logs.
func NewStreamResultWithRequestID(requestID string) *StreamResult {
	result := NewStreamResult()
	result.RequestID = requestID
	return result
}

// Copyright (C) 2025 Aleutian AI (jinterlante@aleutian.ai)
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// See the LICENSE.txt file for the full license text.

// Package main contains the Aleutian CLI chat service implementations.
//
// This file defines the ChatService interface and its implementations for
// communicating with the Aleutian orchestrator's chat endpoints. It follows
// the patterns established in the orchestrator's datatypes package:
//   - All requests and responses have Id and CreatedAt fields for tracing
//   - Interfaces enable dependency injection and testability
//   - Configuration structs group related settings
//
// Architecture:
//
//	CLI Loop → ChatService Interface → HTTPClient Interface → http.Client
//	          ↓                       ↓
//	          ragChatService         mockHTTPClient (tests)
//	          directChatService
//
// See docs/code_quality_lessons/002_http_clients_microservices.md for patterns.
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/jinterlante1206/AleutianLocal/pkg/ux"
	"github.com/jinterlante1206/AleutianLocal/services/orchestrator/datatypes"
)

// =============================================================================
// Response Types
// =============================================================================

// ChatServiceResponse represents a unified response from any ChatService implementation.
//
// This type abstracts the differences between RAG and direct chat responses,
// providing a consistent interface for the CLI to consume regardless of which
// backend is being used.
//
// Fields:
//   - Id: Unique identifier for this response, used for logging and tracing.
//     Generated by the service implementation, not the server.
//   - CreatedAt: Unix timestamp (milliseconds) when the response was created
//     locally. This is the time the CLI received and processed the response.
//   - Answer: The assistant's response text. May be empty if an error occurred.
//   - SessionID: The session identifier for multi-turn conversations.
//     For RAG chat, this is assigned by the server.
//     For direct chat, this may be empty or a client-provided resume ID.
//   - Sources: Retrieved knowledge base sources (RAG only). Empty for direct chat.
//
// Example usage:
//
//	resp, err := service.SendMessage("What is authentication?")
//	if err != nil {
//	    return err
//	}
//	fmt.Println(resp.Answer)
//	for _, src := range resp.Sources {
//	    fmt.Printf("  - %s (score: %.2f)\n", src.Source, src.Score)
//	}
type ChatServiceResponse struct {
	Id        string          `json:"id"`         // Unique response ID (UUID)
	CreatedAt int64           `json:"created_at"` // Unix timestamp (milliseconds)
	Answer    string          `json:"answer"`     // Assistant's response text
	SessionID string          `json:"session_id"` // Session identifier
	Sources   []ux.SourceInfo `json:"sources"`    // Retrieved sources (RAG only)
}

// NewChatServiceResponse creates a new ChatServiceResponse with auto-generated
// Id and CreatedAt timestamp.
//
// Parameters:
//   - answer: The assistant's response text
//   - sessionID: The session identifier
//   - sources: Retrieved sources (may be nil for direct chat)
//
// Returns a pointer to a new ChatServiceResponse with Id and CreatedAt populated.
func NewChatServiceResponse(answer, sessionID string, sources []ux.SourceInfo) *ChatServiceResponse {
	return &ChatServiceResponse{
		Id:        uuid.New().String(),
		CreatedAt: time.Now().UnixMilli(),
		Answer:    answer,
		SessionID: sessionID,
		Sources:   sources,
	}
}

// =============================================================================
// ChatService Interface
// =============================================================================

// ChatService defines the interface for chat operations.
//
// This interface abstracts the communication with different chat backends,
// enabling:
//   - Unit testing via mock implementations
//   - Swapping backends without changing CLI code
//   - Consistent error handling across implementations
//
// Implementations:
//   - ragChatService: Communicates with /v1/chat/rag for RAG-enabled chat
//   - directChatService: Communicates with /v1/chat/direct for direct LLM chat
//
// Thread Safety:
//
//	ChatService implementations are NOT thread-safe. Each goroutine should
//	have its own ChatService instance if concurrent access is needed.
//
// Example usage:
//
//	service := NewRAGChatService(RAGChatServiceConfig{
//	    BaseURL:  "http://localhost:8080",
//	    Pipeline: "reranking",
//	})
//	defer service.Close()
//
//	resp, err := service.SendMessage("What is authentication?")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	fmt.Println(resp.Answer)
type ChatService interface {
	// SendMessage sends a user message and returns the assistant's response.
	//
	// This method handles all HTTP mechanics internally:
	//   - Marshaling the request to JSON
	//   - Making the HTTP POST request
	//   - Parsing the response
	//   - Updating internal state (session ID, message history)
	//
	// Parameters:
	//   - message: The user's input text. Must not be empty.
	//
	// Returns:
	//   - *ChatServiceResponse: The response containing the answer and metadata.
	//     The Id and CreatedAt fields are populated by this method.
	//   - error: Non-nil if the request failed. Errors are wrapped with context
	//     using fmt.Errorf with %w for error chain inspection.
	//
	// Error conditions:
	//   - Network errors (connection refused, timeout)
	//   - Server errors (non-200 status codes)
	//   - Parse errors (invalid JSON response)
	//   - Empty response from server
	SendMessage(message string) (*ChatServiceResponse, error)

	// GetSessionID returns the current session identifier.
	//
	// For RAG chat:
	//   - Returns empty string before first SendMessage call
	//   - Returns server-assigned session ID after first successful response
	//
	// For direct chat:
	//   - Returns the session ID provided in config, or empty string
	//   - Session ID is for client tracking only; server doesn't use it
	GetSessionID() string

	// Close releases any resources held by the service.
	//
	// Currently this is a no-op for HTTP-based implementations, but the
	// interface allows for future implementations that may need cleanup
	// (e.g., WebSocket connections, connection pools).
	//
	// Always call Close when done with the service, preferably with defer:
	//
	//	service := NewRAGChatService(config)
	//	defer service.Close()
	Close() error
}

// =============================================================================
// HTTPClient Interface (for testing)
// =============================================================================

// HTTPClient abstracts HTTP operations to enable mocking in unit tests.
//
// This interface mirrors the relevant methods of http.Client, allowing tests
// to inject mock implementations that return predetermined responses without
// making real network calls.
//
// Production code uses defaultHTTPClient which wraps the standard http.Client.
// Tests use mockHTTPClient which returns configured responses.
//
// See docs/code_quality_lessons/002_http_clients_microservices.md for testing patterns.
//
// Example mock:
//
//	mock := &mockHTTPClient{
//	    response: &http.Response{
//	        StatusCode: 200,
//	        Body: io.NopCloser(strings.NewReader(`{"answer":"Hello"}`)),
//	    },
//	}
//	service := NewRAGChatServiceWithClient(mock, config)
type HTTPClient interface {
	// Post sends an HTTP POST request.
	//
	// Parameters:
	//   - url: The target URL
	//   - contentType: The Content-Type header value (typically "application/json")
	//   - body: The request body reader
	//
	// Returns:
	//   - *http.Response: The response (caller must close Body)
	//   - error: Non-nil if the request failed
	Post(url, contentType string, body io.Reader) (*http.Response, error)

	// Get sends an HTTP GET request.
	//
	// Parameters:
	//   - url: The target URL
	//
	// Returns:
	//   - *http.Response: The response (caller must close Body)
	//   - error: Non-nil if the request failed
	Get(url string) (*http.Response, error)
}

// defaultHTTPClient wraps http.Client to implement the HTTPClient interface.
//
// This is the production implementation used when creating services with
// NewRAGChatService or NewDirectChatService.
type defaultHTTPClient struct {
	client *http.Client
}

// Post implements HTTPClient.Post by delegating to http.Client.Post.
func (c *defaultHTTPClient) Post(url, contentType string, body io.Reader) (*http.Response, error) {
	return c.client.Post(url, contentType, body)
}

// Get implements HTTPClient.Get by delegating to http.Client.Get.
func (c *defaultHTTPClient) Get(url string) (*http.Response, error) {
	return c.client.Get(url)
}

// =============================================================================
// RAG Chat Service
// =============================================================================

// ragChatService implements ChatService for RAG-enabled chat.
//
// This service communicates with the /v1/chat/rag endpoint, which:
//   - Retrieves relevant documents from the knowledge base
//   - Generates responses grounded in those documents
//   - Maintains server-side session state for multi-turn conversations
//
// The service tracks the session ID returned by the server, automatically
// including it in subsequent requests to maintain conversation continuity.
//
// Fields:
//   - client: HTTP client for making requests (injectable for testing)
//   - baseURL: Base URL of the orchestrator service
//   - sessionID: Current session ID (updated after each response)
//   - pipeline: RAG pipeline to use (e.g., "reranking", "graph")
type ragChatService struct {
	client    HTTPClient
	baseURL   string
	sessionID string
	pipeline  string
}

// RAGChatServiceConfig contains configuration for creating a ragChatService.
//
// Fields:
//   - BaseURL: Required. Base URL of the orchestrator (e.g., "http://localhost:8080").
//     Must not include trailing slash.
//   - SessionID: Optional. Resume an existing session by providing its ID.
//     If empty, a new session is created on first request.
//   - Pipeline: Optional. RAG pipeline to use. Defaults to "reranking".
//     Valid values: "standard", "reranking", "raptor", "graph", "rig", "semantic".
//   - Timeout: Optional. HTTP request timeout. Defaults to 3 minutes.
//     RAG requests can be slow due to retrieval and generation.
type RAGChatServiceConfig struct {
	BaseURL   string        // Base URL of orchestrator (required)
	SessionID string        // Session ID to resume (optional)
	Pipeline  string        // RAG pipeline name (optional, default: "reranking")
	Timeout   time.Duration // HTTP timeout (optional, default: 3 minutes)
}

// NewRAGChatService creates a new RAG chat service with default HTTP client.
//
// This is the standard constructor for production use. It creates an HTTP
// client with the configured timeout and connection pooling settings.
//
// Parameters:
//   - config: Service configuration (see RAGChatServiceConfig)
//
// Returns a ChatService implementation for RAG-enabled chat.
//
// Example:
//
//	service := NewRAGChatService(RAGChatServiceConfig{
//	    BaseURL:  getOrchestratorBaseURL(),
//	    Pipeline: "reranking",
//	})
//	defer service.Close()
func NewRAGChatService(config RAGChatServiceConfig) ChatService {
	timeout := config.Timeout
	if timeout == 0 {
		timeout = 3 * time.Minute
	}
	return &ragChatService{
		client: &defaultHTTPClient{
			client: &http.Client{Timeout: timeout},
		},
		baseURL:   config.BaseURL,
		sessionID: config.SessionID,
		pipeline:  config.Pipeline,
	}
}

// NewRAGChatServiceWithClient creates a RAG chat service with a custom HTTP client.
//
// Use this constructor in tests to inject a mock HTTP client:
//
//	mock := &mockHTTPClient{response: mockResponse}
//	service := NewRAGChatServiceWithClient(mock, config)
//
// Parameters:
//   - client: HTTP client implementation (use mockHTTPClient in tests)
//   - config: Service configuration
//
// Returns a ChatService implementation for testing.
func NewRAGChatServiceWithClient(client HTTPClient, config RAGChatServiceConfig) ChatService {
	return &ragChatService{
		client:    client,
		baseURL:   config.BaseURL,
		sessionID: config.SessionID,
		pipeline:  config.Pipeline,
	}
}

// SendMessage sends a message to the /v1/chat/rag endpoint.
//
// Request flow:
//  1. Build ChatRAGRequest with message, session ID, and pipeline
//  2. Marshal to JSON and POST to /v1/chat/rag
//  3. Parse ChatRAGResponse from server
//  4. Update internal session ID from response
//  5. Convert response to ChatServiceResponse
//
// The server-assigned session ID is stored and automatically included
// in subsequent requests for conversation continuity.
func (s *ragChatService) SendMessage(message string) (*ChatServiceResponse, error) {
	requestID := uuid.New().String()
	requestTime := time.Now().UnixMilli()

	url := fmt.Sprintf("%s/v1/chat/rag", s.baseURL)

	reqBody := datatypes.ChatRAGRequest{
		Id:        requestID,
		CreatedAt: requestTime,
		Message:   message,
		SessionId: s.sessionID,
		Pipeline:  s.pipeline,
	}

	postBody, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("marshal request: %w", err)
	}

	resp, err := s.client.Post(url, "application/json", bytes.NewBuffer(postBody))
	if err != nil {
		return nil, fmt.Errorf("http post: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("server error (%d): %s", resp.StatusCode, string(bodyBytes))
	}

	var chatResp datatypes.ChatRAGResponse
	if err := json.Unmarshal(bodyBytes, &chatResp); err != nil {
		return nil, fmt.Errorf("parse response: %w", err)
	}

	// Update session ID for subsequent requests
	if chatResp.SessionId != "" {
		s.sessionID = chatResp.SessionId
	}

	// Convert sources from datatypes to ux format
	sources := make([]ux.SourceInfo, len(chatResp.Sources))
	for i, src := range chatResp.Sources {
		sources[i] = ux.SourceInfo{
			Source:   src.Source,
			Distance: src.Distance,
			Score:    src.Score,
		}
	}

	return NewChatServiceResponse(chatResp.Answer, s.sessionID, sources), nil
}

// GetSessionID returns the current session ID.
//
// Returns empty string if no session has been established yet.
// After the first successful SendMessage, returns the server-assigned session ID.
func (s *ragChatService) GetSessionID() string {
	return s.sessionID
}

// Close releases resources held by the service.
//
// Currently a no-op for HTTP-based implementation.
func (s *ragChatService) Close() error {
	return nil
}

// =============================================================================
// Direct Chat Service
// =============================================================================

// directChatService implements ChatService for direct LLM chat without RAG.
//
// This service communicates with the /v1/chat/direct endpoint, which:
//   - Sends messages directly to the LLM without knowledge base retrieval
//   - Does NOT maintain server-side session state
//
// Unlike ragChatService, this implementation maintains conversation history
// client-side. Each SendMessage call includes the full message history in
// the request, allowing the LLM to maintain context across turns.
//
// The message history is managed automatically:
//   - System message is added on construction
//   - User messages are appended before each request
//   - Assistant responses are appended after successful responses
//   - On error, the last user message is removed to maintain consistency
//
// Fields:
//   - client: HTTP client for making requests
//   - baseURL: Base URL of the orchestrator service
//   - sessionID: Client-side session identifier (for tracking only)
//   - messages: Conversation history (system + user + assistant messages)
//   - enableThinking: Enable extended thinking mode (Claude only)
//   - budgetTokens: Token budget for thinking mode
type directChatService struct {
	client         HTTPClient
	baseURL        string
	sessionID      string
	messages       []datatypes.Message
	enableThinking bool
	budgetTokens   int
}

// DirectChatServiceConfig contains configuration for creating a directChatService.
//
// Fields:
//   - BaseURL: Required. Base URL of the orchestrator.
//   - SessionID: Optional. Client-side session identifier for tracking.
//     Unlike RAG chat, the server does not use this value.
//   - EnableThinking: Optional. Enable extended thinking for Claude models.
//   - BudgetTokens: Optional. Token budget for thinking mode (default: 2048).
//   - Timeout: Optional. HTTP request timeout (default: 3 minutes).
type DirectChatServiceConfig struct {
	BaseURL        string        // Base URL of orchestrator (required)
	SessionID      string        // Client-side session ID (optional)
	EnableThinking bool          // Enable extended thinking (optional)
	BudgetTokens   int           // Token budget for thinking (optional)
	Timeout        time.Duration // HTTP timeout (optional)
}

// NewDirectChatService creates a new direct chat service with default HTTP client.
//
// The service is initialized with a system message that establishes the
// assistant's personality. Additional configuration for extended thinking
// (Claude only) can be provided via config.
//
// Parameters:
//   - config: Service configuration (see DirectChatServiceConfig)
//
// Returns a pointer to directChatService. Note: Returns concrete type to
// allow access to LoadSessionHistory method.
func NewDirectChatService(config DirectChatServiceConfig) *directChatService {
	timeout := config.Timeout
	if timeout == 0 {
		timeout = 3 * time.Minute
	}

	svc := &directChatService{
		client: &defaultHTTPClient{
			client: &http.Client{Timeout: timeout},
		},
		baseURL:        config.BaseURL,
		sessionID:      config.SessionID,
		enableThinking: config.EnableThinking,
		budgetTokens:   config.BudgetTokens,
		messages:       make([]datatypes.Message, 0, 10), // Pre-allocate for typical conversation
	}

	// Add system message to establish assistant personality
	svc.messages = append(svc.messages, datatypes.Message{
		Role:    "system",
		Content: "You are a helpful, technically gifted assistant",
	})

	return svc
}

// NewDirectChatServiceWithClient creates a direct chat service with custom HTTP client.
//
// Use this constructor in tests to inject a mock HTTP client.
func NewDirectChatServiceWithClient(client HTTPClient, config DirectChatServiceConfig) *directChatService {
	svc := &directChatService{
		client:         client,
		baseURL:        config.BaseURL,
		sessionID:      config.SessionID,
		enableThinking: config.EnableThinking,
		budgetTokens:   config.BudgetTokens,
		messages:       make([]datatypes.Message, 0, 10),
	}

	svc.messages = append(svc.messages, datatypes.Message{
		Role:    "system",
		Content: "You are a helpful, technically gifted assistant",
	})

	return svc
}

// SendMessage sends a message to the /v1/chat/direct endpoint.
//
// Request flow:
//  1. Append user message to history
//  2. Build request with full message history
//  3. POST to /v1/chat/direct
//  4. Parse response
//  5. Append assistant message to history (or remove user message on error)
//
// Error recovery:
//
//	If any step fails after adding the user message, the message is removed
//	from history to maintain consistency. This ensures the next SendMessage
//	call doesn't include a dangling user message.
func (s *directChatService) SendMessage(message string) (*ChatServiceResponse, error) {
	url := fmt.Sprintf("%s/v1/chat/direct", s.baseURL)

	// Add user message to history
	s.messages = append(s.messages, datatypes.Message{Role: "user", Content: message})

	reqBody := DirectChatRequest{
		Messages:       s.messages,
		EnableThinking: s.enableThinking,
		BudgetTokens:   s.budgetTokens,
	}

	postBody, err := json.Marshal(reqBody)
	if err != nil {
		s.removeLastMessage()
		return nil, fmt.Errorf("marshal request: %w", err)
	}

	resp, err := s.client.Post(url, "application/json", bytes.NewBuffer(postBody))
	if err != nil {
		s.removeLastMessage()
		return nil, fmt.Errorf("http post: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		s.removeLastMessage()
		return nil, fmt.Errorf("read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		s.removeLastMessage()
		return nil, fmt.Errorf("server error (%d): %s", resp.StatusCode, string(bodyBytes))
	}

	var chatResp DirectChatResponse
	if err := json.Unmarshal(bodyBytes, &chatResp); err != nil {
		s.removeLastMessage()
		return nil, fmt.Errorf("parse response: %w", err)
	}

	if chatResp.Answer == "" {
		s.removeLastMessage()
		return nil, fmt.Errorf("empty response from server")
	}

	// Add assistant response to history
	s.messages = append(s.messages, datatypes.Message{Role: "assistant", Content: chatResp.Answer})

	// Direct chat has no sources
	return NewChatServiceResponse(chatResp.Answer, s.sessionID, nil), nil
}

// removeLastMessage removes the last message from history.
//
// Called on error to maintain message history consistency.
// Safe to call even if messages is empty.
func (s *directChatService) removeLastMessage() {
	if len(s.messages) > 0 {
		s.messages = s.messages[:len(s.messages)-1]
	}
}

// GetSessionID returns the client-side session identifier.
//
// For direct chat, this is purely for client tracking and is not used by
// the server.
func (s *directChatService) GetSessionID() string {
	return s.sessionID
}

// Close releases resources held by the service.
//
// Currently a no-op for HTTP-based implementation.
func (s *directChatService) Close() error {
	return nil
}

// LoadSessionHistory loads previous conversation history for session resume.
//
// This method fetches conversation history from the server and populates
// the message history, allowing continuation of a previous conversation.
//
// Parameters:
//   - sessionID: The session ID to resume
//
// Returns:
//   - int: Number of conversation turns loaded
//   - error: Non-nil if loading failed
//
// Side effects:
//   - Replaces current message history with loaded history
//   - Updates sessionID to the provided value
//
// Example:
//
//	service := NewDirectChatService(config)
//	turns, err := service.LoadSessionHistory("sess-abc123")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	fmt.Printf("Loaded %d previous turns\n", turns)
func (s *directChatService) LoadSessionHistory(sessionID string) (int, error) {
	historyURL := fmt.Sprintf("%s/v1/sessions/%s/history", s.baseURL, sessionID)

	resp, err := s.client.Get(historyURL)
	if err != nil {
		return 0, fmt.Errorf("http get: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return 0, fmt.Errorf("failed to get history (status %d)", resp.StatusCode)
	}

	// Parse Weaviate-style response
	type HistoryTurn struct {
		Question string `json:"question"`
		Answer   string `json:"answer"`
	}
	var historyResp map[string]map[string][]HistoryTurn
	if err := json.NewDecoder(resp.Body).Decode(&historyResp); err != nil {
		return 0, fmt.Errorf("parse history: %w", err)
	}

	history, ok := historyResp["Get"]["Conversation"]
	if !ok {
		return 0, fmt.Errorf("no conversation data in history response")
	}

	// Reset messages and rebuild from history
	s.messages = make([]datatypes.Message, 0, len(history)*2+1)
	s.messages = append(s.messages, datatypes.Message{
		Role:    "system",
		Content: "You are a helpful, technically gifted assistant",
	})

	for _, turn := range history {
		s.messages = append(s.messages, datatypes.Message{Role: "user", Content: turn.Question})
		s.messages = append(s.messages, datatypes.Message{Role: "assistant", Content: turn.Answer})
	}

	s.sessionID = sessionID
	return len(history), nil
}

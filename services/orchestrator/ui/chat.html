<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aleutian Chat</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script src="./lucide.min.js"></script>
    <script src="./markdown-it.min.js"></script>

    <style>
        :root {
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            --gray-50: #f9f9f9; --gray-100: #f2f2f7; --gray-200: #e5e5ea; --gray-300: #d1d1d6; --gray-400: #aeaeb2; --gray-500: #8e8e93; --gray-600: #636366; --gray-800: #1c1c1e; --gray-900: #000000; --white: #FFFFFF;
            --brand-light: #20B9B4; --brand-default: #1D9DA0; --brand-dark: #16858E; --brand-darker: #157483;
            --system-blue: #0A84FF; --system-red: #FF453A; --system-green: #30D158;
            --border-radius-s: 0.375rem; --border-radius-m: 0.625rem; --transition: all 0.2s ease-in-out;
            --material-background: rgba(242, 242, 247, 0.85);
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        html, body { font-family: var(--font-sans); color: var(--gray-800); line-height: 1.6; height: 100vh; width: 100vw; overflow: hidden; background-color: var(--gray-100); display: flex; flex-direction: column; }
        pre, code { font-family: var(--font-mono); }
        .hidden { display: none; }
        ::-webkit-scrollbar { width: 14px; height: 14px; background: transparent; }
        ::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 7px; border: 4px solid transparent; background-clip: content-box; }
        ::-webkit-scrollbar-thumb:hover { background-color: rgba(0,0,0,0.3); }
        ::-webkit-scrollbar-track { background: transparent; }

        /* Main 3-Column Layout */
        #app-layout { display: flex; flex-grow: 1; width: 100%; height: 100%; overflow: hidden; }

        /* Column 1: Sidebar */
        #sidebar {
            width: 260px;
            flex-shrink: 0;
            background-color: var(--material-background);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid var(--gray-200);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .sidebar-group {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-bottom: 1px solid var(--gray-200);
        }
        .sidebar-group.sessions { flex-grow: 1; min-height: 150px; }
        .sidebar-group.documents { flex-shrink: 0; max-height: 40%; }

        .sidebar-header {
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .sidebar-header h2 { font-size: 1rem; font-weight: 600; color: var(--gray-900); }
        .sidebar-header button {
            background: none; border: none; cursor: pointer; color: var(--system-blue);
            padding: 4px; border-radius: var(--border-radius-s);
        }
        .sidebar-header button:hover { background-color: rgba(0,0,0,0.05); }

        .sidebar-list {
            list-style: none;
            padding: 0.75rem;
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .sidebar-item {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            border-radius: var(--border-radius-s);
            cursor: pointer;
            color: var(--gray-600);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .sidebar-item:hover { background-color: rgba(0,0,0,0.05); }
        .sidebar-item.active {
            background-color: var(--system-blue);
            color: var(--white);
            font-weight: 500;
        }
        .sidebar-item.document-item {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            cursor: default;
        }
        .sidebar-no-item {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            color: var(--gray-400);
            font-style: italic;
        }

        /* Column 2: Main Content */
        #main-content { flex-grow: 1; display: flex; flex-direction: column; background: var(--white); overflow: hidden; }
        #message-log { flex-grow: 1; overflow-y: auto; padding: 1.5rem; display: flex; flex-direction: column; gap: 1.5rem; }
        .message { display: flex; gap: 1rem; max-width: 90%; }
        .message-icon { flex-shrink: 0; width: 2.5rem; height: 2.5rem; border-radius: 9999px; display: flex; align-items: center; justify-content: center; color: var(--white); }
        .message.user .message-icon { background-color: var(--gray-500); }
        .message.assistant .message-icon { background-color: var(--brand-default); }

        .message-content { padding-top: 0.25rem; max-width: 100%; overflow: hidden; width: 100%; }
        .message-content strong { display: block; font-weight: 600; color: var(--gray-900); }
        .message-content p { margin-top: 0.25rem; color: var(--gray-800); }
        .message-content h1,
        .message-content h2,
        .message-content h3 { font-weight: 600; margin-top: 1.25em; margin-bottom: 0.5em; color: var(--gray-900); }
        .message-content h1 { font-size: 1.5rem; }
        .message-content h2 { font-size: 1.25rem; }
        .message-content h3 { font-size: 1.1rem; }
        .message-content ul,
        .message-content ol { margin-top: 0.5em; margin-bottom: 1em; padding-left: 1.5rem; }
        .message-content li { margin-top: 0.25em; }
        .message-content blockquote { margin: 1em 0; padding-left: 1em; border-left: 3px solid var(--system-blue); color: var(--gray-600); }
        .message-content pre { background-color: var(--gray-800); color: var(--gray-100); padding: 1rem; border-radius: var(--border-radius-m); margin: 1rem 0; overflow-x: auto; }
        .message-content code { font-size: 0.875rem; }
        .message-content p > code, .message-content li > code { background-color: var(--gray-100); color: var(--brand-darker); padding: 0.15rem 0.3rem; border-radius: 4px; font-size: 0.85em; }

        .sources-box { background: var(--gray-50); border: 1px solid var(--gray-200); border-radius: var(--border-radius-m); padding: 1rem; margin-top: 1rem; }
        .sources-box h4 { font-weight: 600; font-size: 0.875rem; color: var(--brand-dark); margin-bottom: 0.5rem; }
        .sources-list { list-style: none; display: flex; flex-wrap: wrap; gap: 0.5rem; }
        .source-item { font-family: var(--font-mono); font-size: 0.8rem; color: var(--gray-600); background: var(--white); border: 1px solid var(--gray-300); padding: 0.25rem 0.5rem; border-radius: 4px; }

        .message.user { align-self: flex-start; }
        .message.assistant { align-self: flex-start; }

        .approval-card { background: var(--gray-50); border: 1px solid var(--gray-200); border-radius: var(--border-radius-m); padding: 1rem; }
        .approval-card h4 { font-weight: 600; color: var(--gray-800); }
        .approval-card p { font-size: 0.875rem; color: var(--gray-600); }
        .approval-card pre { background-color: var(--white); border: 1px solid var(--gray-200); padding: 0.75rem; margin: 0.75rem 0; }
        .approval-buttons { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 1rem; }
        .approval-buttons button { display: inline-flex; align-items: center; gap: 0.5rem; font-family: var(--font-sans); font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border-radius: var(--border-radius-s); border: 1px solid transparent; cursor: pointer; transition: var(--transition); }
        .approve-btn { background-color: var(--system-green); color: var(--white); }
        .approve-btn:hover:not(:disabled) { background-color: #28a745; }
        .deny-btn { background-color: var(--system-red); color: var(--white); }
        .deny-btn:hover:not(:disabled) { background-color: #dc3545; }
        .approval-buttons button:disabled { background-color: var(--gray-200); color: var(--gray-400); cursor: not-allowed; }

        /* Form Container */
        #chat-form-container {
            border-top: 1px solid var(--gray-200);
            padding: 1rem 1.5rem;
            background: var(--gray-50);
            flex-shrink: 0;
        }
        #file-preview {
            font-size: 0.8rem;
            font-family: var(--font-mono);
            color: var(--gray-600);
            margin-bottom: 0.75rem;
            background: var(--gray-100);
            padding: 0.5rem 0.75rem;
            border-radius: var(--border-radius-s);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #file-preview-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        #clear-file-btn {
            background: none; border: none; color: var(--gray-500); cursor: pointer;
            padding: 2px; border-radius: 99px;
        }
        #clear-file-btn:hover { background: var(--gray-200); color: var(--gray-800); }

        #chat-form { display: flex; gap: 1rem; align-items: center; }

        #chat-input {
            flex-grow: 1; padding: 0.75rem 1rem; font-family: var(--font-sans); font-size: 1rem; border: 1px solid var(--gray-300); border-radius: var(--border-radius-m);
        }
        #chat-input:focus { outline: none; border-color: var(--system-blue); box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.2); }

        #file-upload-label {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem;
            height: 46px; /* Match input height */
            border: 1px solid var(--gray-300);
            border-radius: var(--border-radius-m);
            background: var(--white);
            cursor: pointer;
            color: var(--gray-600);
            transition: var(--transition);
        }
        #file-upload-label:hover { border-color: var(--system-blue); color: var(--system-blue); }
        #file-upload-input { display: none; }

        #send-button {
            display: inline-flex; align-items: center; justify-content: center; padding: 0 1rem;
            height: 46px; /* Match input height */
            border: none; font-size: 1rem; font-weight: 500; border-radius: var(--border-radius-m); cursor: pointer; transition: var(--transition);
            color: var(--white); background-color: var(--system-blue);
        }
        #send-button:hover:not(:disabled) { background-color: #0070e0; }
        #send-button:disabled { background-color: var(--gray-300); cursor: not-allowed; }

        #thinking-spinner { align-self: flex-start; margin-left: 4.5rem; padding: 0 1.5rem; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .spinner { animation: spin 1s linear infinite; }

        /* Column 3: Inspector */
        #inspector { width: 280px; flex-shrink: 0; background-color: var(--material-background); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-left: 1px solid var(--gray-200); padding: 1.5rem 1rem; overflow-y: auto; display: flex; flex-direction: column; gap: 1.5rem; }
        .inspector-group h3 { font-size: 0.75rem; font-weight: 600; color: var(--gray-500); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--gray-200); }
        .inspector-group p { font-size: 0.875rem; color: var(--gray-600); }
        #session-id-display, #current-mode-display { font-family: var(--font-mono); font-size: 0.8rem; color: var(--gray-800); word-wrap: break-word; background: rgba(0,0,0,0.03); padding: 0.5rem; border-radius: var(--border-radius-s); }

        /* New Toggle Switch Styles */
        .rag-toggle-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            height: 46px; /* Match input height */
            border: 1px solid var(--gray-300);
            border-radius: var(--border-radius-m);
            background: var(--white);
            cursor: pointer;
        }
        .rag-toggle-container:has(:disabled) {
            background-color: var(--gray-100);
            cursor: not-allowed;
            opacity: 0.7;
        }
        .rag-toggle-container span {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--gray-600);
            pointer-events: none; /* Make text non-interactive */
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--gray-300);
            border-radius: 34px;
            transition: var(--transition);
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: var(--transition);
        }
        input:checked + .toggle-slider {
            background-color: var(--system-green);
        }
        input:checked + .toggle-slider:before {
            transform: translateX(16px);
        }
    </style>
</head>
<body>
    <div id="app-layout">
        <div id="sidebar">
            <!-- Sessions List -->
            <div class="sidebar-group sessions">
                <div class="sidebar-header">
                    <h2>Sessions</h2>
                    <button id="new-chat-btn" title="New Chat">
                        <i data-lucide="file-plus-2"></i>
                    </button>
                </div>
                <ul id="session-list" class="sidebar-list">
                    <!-- JS will populate this -->
                </ul>
            </div>

            <!-- Global Documents List -->
            <div class="sidebar-group documents" id="global-documents-group">
                <div class="sidebar-header">
                    <h2>Global Documents</h2>
                    <button id="refresh-docs-btn" title="Refresh Documents">
                        <i data-lucide="refresh-cw" style="width:14px; height:14px;"></i>
                    </button>
                </div>
                <ul id="doc-list" class="sidebar-list">
                    <li class="sidebar-no-item">No documents</li>
                </ul>
            </div>

            <!-- Local (Session) Documents List -->
            <div class="sidebar-group documents" id="local-documents-group">
                <div class="sidebar-header">
                    <h2>Local Documents</h2>
                </div>
                <ul id="local-doc-list" class="sidebar-list">
                    <li class="sidebar-no-item">No local documents</li>
                </ul>
            </div>
        </div>

        <div id="main-content">
            <div id="message-log">
                <!-- JS will populate this -->
            </div>

            <div id="thinking-spinner" class="hidden">
                <i data-lucide="loader-2" class="spinner" style="color: var(--brand-dark);"></i>
            </div>

            <div id="chat-form-container">
                <!-- File Preview Bar (for staging uploads) -->
                <div id="file-preview" class="hidden">
                    <span id="file-preview-name"></span>
                    <button id="clear-file-btn" title="Clear file">
                        <i data-lucide="x" style="width:16px; height:16px;"></i>
                    </button>
                </div>

                <!-- Chat Form -->
                <form id="chat-form">

                    <!-- RAG Toggle (replaces dropdown) -->
                    <label class="rag-toggle-container" for="rag-toggle-checkbox" title="Toggle RAG (Retrieval-Augmented Generation)">
                        <label class="toggle-switch">
                            <input type="checkbox" id="rag-toggle-checkbox" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>RAG</span>
                    </label>

                    <!-- File Upload Button -->
                    <label for="file-upload-input" id="file-upload-label" title="Attach file">
                        <i data-lucide="paperclip"></i>
                    </label>
                    <input type="file" id="file-upload-input">

                    <!-- Chat Input -->
                    <input type="text" id="chat-input" placeholder="Ask Aleutian anything..." autocomplete="off">

                    <!-- Send Button -->
                    <button type="submit" id="send-button">
                        <i data-lucide="send-horizontal"></i>
                    </button>
                </form>
            </div>
        </div>

        <div id="inspector">
            <div class="inspector-group">
                <h3>Session</h3>
                <p id="session-id-display">(Connecting...)</p>
            </div>
            <div class="inspector-group">
                <h3>Mode</h3>
                <p id="current-mode-display">chat-rag</p>
            </div>
            <div class="inspector-group">
                <h3>Info</h3>
                <p>This panel can show RAG sources, token counts, or other metadata about the conversation.</p>
            </div>
            <div class="inspector-group">
              <div class="sidebar-header" style="padding: 0; border-bottom: 1px solid var(--gray-200); margin-bottom: 0.5rem;">
                <h3 style="font-size: 0.75rem; font-weight: 600; color: var(--gray-500); text-transform: uppercase; letter-spacing: 0.05em; border: none; margin: 0; padding: 0;">Session</h3>
                <button id="download-chat-btn" title="Download Chat History" style="background: none; border: none; cursor: pointer; color: var(--system-blue); padding: 4px; border-radius: var(--border-radius-s);">
                  <i data-lucide="download" style="width:16px; height:16px;"></i>
                </button>
              </div>
              <p id="session-id-display">(Connecting...)</p>
            </div>
        </div>
    </div>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

          lucide.createIcons();
          const md = window.markdownit({ html: false, linkify: true, typographer: true });

          // --- 1. Get DOM Elements ---
          const messageLog = document.getElementById('message-log');
          const chatForm = document.getElementById('chat-form');
          const chatInput = document.getElementById('chat-input');
          const sendButton = document.getElementById('send-button');
          const thinkingSpinner = document.getElementById('thinking-spinner');
          const newChatBtn = document.getElementById('new-chat-btn');
          const sessionList = document.getElementById('session-list');

          // Document Lists
          const documentList = document.getElementById('doc-list');
          const localDocList = document.getElementById('local-doc-list');
          const globalDocumentsGroup = document.getElementById('global-documents-group');
          const localDocumentsGroup = document.getElementById('local-documents-group');
          const refreshDocsBtn = document.getElementById('refresh-docs-btn');

          // Inspector Panel
          const sessionIdDisplay = document.getElementById('session-id-display');
          const currentModeDisplay = document.getElementById('current-mode-display');
          const downloadChatBtn = document.getElementById('download-chat-btn');

          // File Upload
          const fileUploadInput = document.getElementById('file-upload-input');
          const filePreview = document.getElementById('file-preview');
          const filePreviewName = document.getElementById('file-preview-name');
          const clearFileBtn = document.getElementById('clear-file-btn');

          // RAG Toggle (replaces chatMode)
          const ragToggle = document.getElementById('rag-toggle-checkbox');

          // --- 2. State Management (Frontend) ---
          let currentMode = ragToggle.checked ? 'chat-rag' : 'chat-no-rag';
          let isFirstTurn = true;
          let globalSessionId = null;
          let ws;
          let chatHistories = {};
          let fileToUpload = null;
          let approvalDataCache = {};

          // --- 3. WebSocket Connection ---
          const wsProtocol = window.location.protocol === "https:" ? "wss://" : "ws://";
          const wsURL = `${wsProtocol}${window.location.host}/v1/chat/ws`;

          function connect() {
            ws = new WebSocket(wsURL);

            ws.onopen = () => {
              console.log("WebSocket connected");
              sendButton.disabled = false;
              chatInput.disabled = false;
              chatInput.focus();
              updateMessageLog();
              fetchSessions();
              fetchDocuments();
              updateSidebarDocVisibility(currentMode);

              // Poll for new sessions every 5 seconds
              setInterval(fetchSessions, 5000);
              // Poll for new documents every 30 seconds
              setInterval(fetchDocuments, 30000);
            };

            ws.onmessage = (event) => {
                setLoadingState(false);
                const resp = JSON.parse(event.data);
                if (resp.action) {
                    handleAction(resp);
                } else {
                    handleChat(resp);
                }
            };

            ws.onclose = () => {
                console.log("WebSocket disconnected.");
                sendButton.disabled = true;
                chatInput.disabled = true;
                if (!globalSessionId) {
                  addMessage("assistant", "**Connection lost. Attempting to reconnect...**");
                  setTimeout(connect, 3000);
                }
            };

            ws.onerror = (err) => {
                console.error("WebSocket error:", err);
                addMessage("assistant", "**Connection error. Please refresh.**");
                ws.close();
            };
          }

          // --- 4. Event Handlers ---

          // Start a new chat session
          newChatBtn.addEventListener('click', () => {
            console.log("Starting new chat...");
            globalSessionId = null;
            isFirstTurn = true; // Reset first turn flag

            if (localDocList) localDocList.innerHTML =
                '<li class="sidebar-no-item">No local documents</li>'
            // Re-enable and reset the RAG toggle
            ragToggle.disabled = false;
            ragToggle.checked = true;
            currentMode = 'chat-rag';
            currentModeDisplay.textContent = currentMode;

            sessionIdDisplay.textContent = "(Connecting...)";
            initWelcomeMessages(); // Reset welcome messages
            updateMessageLog(); // Show the new welcome message
            updateSidebarDocVisibility(currentMode); // Update sidebar

            if (ws) {
               ws.close(); // Close old connection
            }
            setTimeout(connect, 100); // Start new connection
          });

          // Handle form submission (sending a message)
          chatForm.addEventListener('submit', (e) => {
              e.preventDefault();

              // 1. Handle File Upload (if one is staged)
              if (fileToUpload) {
                  handleFileUpload(fileToUpload);
                  return; // Don't send a chat message
              }

              // 2. Handle Chat Message
              const query = chatInput.value.trim();
              if (!query || sendButton.disabled) return;

              // Read the *current* state of the RAG toggle
              currentMode = ragToggle.checked ? 'chat-rag' : 'chat-no-rag';
              currentModeDisplay.textContent = currentMode;

              addMessage("user", query);
              setLoadingState(true);

              // Use the unified session history
              if (!chatHistories[globalSessionId]) {
                  // This case handles the very first message
                  // We take the welcome message and add the user's query
                  const welcomeHistory = chatHistories[currentMode] || [];
                  chatHistories[globalSessionId] = [...welcomeHistory, { role: 'user', content: query }];
              } else {
                  chatHistories[globalSessionId].push({ role: 'user', content: query });
              }

              let historyForBackend = [];
              if (currentMode === 'chat-no-rag') {
                  // For "no RAG", map the unified history for the backend
                  historyForBackend = chatHistories[globalSessionId]
                      .filter(msg => !msg.content.startsWith('Welcome!')) // Don't send welcome prompts
                      .map(msg => ({ role: msg.role, content: msg.content }));
              }

              ws.send(JSON.stringify({
                  mode: currentMode,
                  query: query,
                  history: historyForBackend // Send history only if in 'no-rag' mode
              }));

              chatInput.value = '';
          });

          // RAG toggle changes the mode
          ragToggle.addEventListener('change', (e) => {
              currentMode = e.target.checked ? 'chat-rag' : 'chat-no-rag';
              currentModeDisplay.textContent = currentMode;
              // Call our new visibility function
              updateSidebarDocVisibility(currentMode);
              if (currentMode.includes('no-rag') && fileToUpload) {
                clearFileSelection();
              }
          });

          // Handle clicking on a session in the list
          sessionList.addEventListener('click', (e) => {
              const clickedItem = e.target.closest('.session-item');
              if (clickedItem && clickedItem.dataset.sessionId) {
                const sessionIdToLoad = clickedItem.dataset.sessionId;

                // Don't reload if it's already active
                if (sessionIdToLoad === globalSessionId) return;

                // Close existing connection to start fresh
                if (ws) ws.close();

                // Remove 'active' from all other items
                sessionList.querySelectorAll('.session-item').forEach(item => {
                  item.classList.remove('active');
                });

                // Add 'active' to the clicked item
                clickedItem.classList.add('active');

                // Load the session (this will set globalSessionId)
                loadSessionHistory(sessionIdToLoad);

                // Re-connect WebSocket
                setTimeout(connect, 100);
              }
          });

          // Handle refreshing the global document list
          if (refreshDocsBtn) {
              refreshDocsBtn.addEventListener('click', (e) => {
                e.preventDefault();
                console.log("Manual refresh of global documents triggered...");
                fetchDocuments();
              });
          }

          // Handle file staging (paperclip)
          fileUploadInput.addEventListener('change', (e) => {
              if (e.target.files && e.target.files[0]) {
                fileToUpload = e.target.files[0];
                filePreviewName.textContent = fileToUpload.name;
                filePreview.classList.remove('hidden');
                chatInput.placeholder = "Click Send to upload and scan file...";
                chatInput.disabled = true;
                sendButton.disabled = false;
              }
          });

          downloadChatBtn.addEventListener('click', () => {
              downloadChatHistory();
          });

          // Handle clearing the staged file
          clearFileBtn.addEventListener('click', clearFileSelection);

          // Handle approval card button clicks
          messageLog.addEventListener('click', (e) => {
              const button = e.target.closest('button[data-decision]');
              if (!button) return;

              const path = button.dataset.path;
              const decision = button.dataset.decision;

              button.parentElement.querySelectorAll('button').forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.7';
              });
              setLoadingState(true);

              const base64data = approvalDataCache[path];
              if (!base64data) {
                addMessage('assistant', `**Error:** File data cache lost for \`${path}\`. Please upload again.`);
                setLoadingState(false);
                return;
              }

              let finalDecision = "deny";
              let scope = "global"; // Default

              if (decision === "approve-session") {
                finalDecision = "approve";
                scope = "session";
              } else if (decision === "approve-global") {
                finalDecision = "approve";
                scope = "global";
              }

              ws.send(JSON.stringify({
                action: 'file_upload_confirm',
                filename: path,
                decision: finalDecision,
                scope: scope,
                base64data: base64data
              }));

              delete approvalDataCache[path];
          });


          // --- 5. Logic & UI Functions ---

          function initWelcomeMessages() {
              // This just defines the *templates* for new chats
              chatHistories = {
                  'chat-rag': [{ role: 'assistant', content: 'Welcome! **RAG mode** is active. I will use documents to answer.', sources: [] }],
                  'chat-no-rag': [{ role: 'assistant', content: 'Welcome! **No RAG** mode is active. I will not use documents.', sources: [] }]
              };
          }

          function setLoadingState(isLoading) {
              if (isLoading) {
                thinkingSpinner.classList.remove('hidden');
                sendButton.disabled = true;
                chatInput.disabled = true;
              } else {
                thinkingSpinner.classList.add('hidden');
                sendButton.disabled = false;
                chatInput.disabled = false;
                chatInput.focus();
              }
              scrollToBottom();
          }

          function clearFileSelection() {
              fileToUpload = null;
              fileUploadInput.value = null; // Clear the file input's memory
              filePreview.classList.add('hidden');
              chatInput.placeholder = "Ask Aleutian anything...";
              chatInput.disabled = false;
          }

          function handleFileUpload(file) {
              setLoadingState(true);
              addMessage('user', `Uploading file: \`${file.name}\``);

              // Add to history
              if (!chatHistories[globalSessionId]) { chatHistories[globalSessionId] = []; }
              chatHistories[globalSessionId].push({ role: 'user', content: `Uploading file: \`${file.name}\`` });

              const reader = new FileReader();
              reader.onload = (e) => {
                const base64data = e.target.result.split(',')[1];
                approvalDataCache[file.name] = base64data; // Cache for confirmation

                ws.send(JSON.stringify({
                  action: 'file_upload_scan',
                  filename: file.name,
                  base64data: base64data
                }));

                // IMPORTANT: Clear the file selection *after sending*
                clearFileSelection();
              };
              reader.onerror = (err) => {
                console.error("Failed to read file:", err);
                addMessage('assistant', `**Error:** Failed to read file \`${file.name}\``);
                setLoadingState(false);
              };
              reader.readAsDataURL(file);
          }

          function handleAction(resp) {
              setLoadingState(false);
              let message = resp.message;

              switch (resp.action) {
                case 'session_created':
                  globalSessionId = resp.sessionId;
                  sessionIdDisplay.textContent = globalSessionId;
                  // Now that we have a session ID, create its history cache
                  chatHistories[globalSessionId] = [...(chatHistories[currentMode] || [])];
                  updateMessageLog();
                  break;

                case 'populate_approval_required':
                  addApprovalCard(resp.path, resp.findings);
                  // Add to history
                  chatHistories[globalSessionId].push({ role: 'assistant', content: `Approval required for ${resp.path}`, type: 'approval' });
                  break;

                case 'populate_ingest':
                case 'populate_final':
                  addMessage('assistant', message);
                  // Add to history
                  chatHistories[globalSessionId].push({ role: 'assistant', content: message });

                  if (message && message.includes('Success')) {
                    // Refresh *both* document lists
                    setTimeout(fetchDocuments, 1000);
                    setTimeout(() => fetchLocalDocuments(globalSessionId), 1000);
                  }
                  break;

                case 'sessions_updated':
                  console.log("Server pushed session update, refetching...");
                  fetchSessions();
                  break;

                case 'documents_updated':
                  console.log("Server pushed document update, refetching...");
                  fetchDocuments();
                  break;

                default:
                  console.warn("Received unknown action:", resp);
              }
          }

          function handleChat(resp) {
              setLoadingState(false);
              if (resp.error) {
                  addMessage('assistant', `**Error:** ${resp.error}`);
                  chatHistories[globalSessionId].push({ role: 'assistant', content: `**Error:** ${resp.error}` });
              } else {
                  addMessage("assistant", resp.answer, resp.sources);
                  // Add to the unified session history
                  chatHistories[globalSessionId].push({ role: 'assistant', content: resp.answer, sources: resp.sources });

                  // Check if this is the first *user* message of the session
                  const history = chatHistories[globalSessionId] || [];
                  const userMessages = history.filter(m => m.role === 'user').length;
                  if (userMessages === 1) {
                      console.log("First turn complete, refreshing session list.");
                      setTimeout(fetchSessions, 500); // Refresh session list to show new summary
                      // Lock the RAG toggle after the first message (welcome or chat)
                      if (isFirstTurn) {
                          ragToggle.disabled = true;
                          isFirstTurn = false;
                      }
                  }
              }
          }

          async function fetchSessions() {
              try {
                const response = await fetch('/v1/sessions');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();
                sessionList.innerHTML = '';

                if (result.Get && result.Get.Session && result.Get.Session.length > 0) {
                  result.Get.Session.forEach((session, index) => {
                    const li = document.createElement('li');
                    li.className = 'sidebar-item session-item';

                    if (session.session_id === globalSessionId) {
                      li.classList.add('active');
                    }

                    li.textContent = session.summary;
                    li.title = session.summary + `\n(ID: ${session.session_id})`;
                    li.dataset.sessionId = session.session_id;
                    sessionList.appendChild(li);
                  });
                } else {
                  sessionList.innerHTML = '<li class="sidebar-no-item">No past sessions</li>';
                }
              } catch (error) {
                console.error("Failed to fetch sessions:", error);
                sessionList.innerHTML = '<li class="sidebar-item" style="color: var(--system-red);">Failed to load</li>';
              }
          }

          async function loadSessionHistory(sessionId) {
              console.log(`Loading history for session: ${sessionId}`);
              try {
                  // 1. Fetch the chat history
                  const response = await fetch(`/v1/sessions/${sessionId}/history`);
                  if (!response.ok) throw new Error(`History fetch failed: ${response.status}`);
                  const result = await response.json();

                  // 2. Set the global state
                  globalSessionId = sessionId;
                  isFirstTurn = false; // This is an existing session
                  ragToggle.disabled = true; // Lock the toggle when loading a session
                  sessionIdDisplay.textContent = globalSessionId;

                  // 3. Rebuild the chat history for the frontend
                  chatHistories[globalSessionId] = []; // Clear/create cache for this session
                  if (result.Get && result.Get.Conversation) {
                      result.Get.Conversation.forEach(turn => {
                          // The backend gives us {question, answer}
                          chatHistories[globalSessionId].push({
                              role: 'user',
                              content: turn.question
                          });
                          chatHistories[globalSessionId].push({
                              role: 'assistant',
                              content: turn.answer,
                              sources: turn.sources || [] // Add sources if backend provides them
                          });
                      });
                  }

                  // 4. Fetch this session's local documents
                  await fetchLocalDocuments(sessionId); // This function already exists

                  // 5. Update the UI
                  updateMessageLog(); // This will show the history

                  // 6. Guess the mode from the last message
                  const history = chatHistories[globalSessionId] || [];
                  const lastMsg = history[history.length - 1];
                  if (lastMsg && lastMsg.sources && lastMsg.sources.length > 0) {
                      currentMode = 'chat-rag';
                      ragToggle.checked = true;
                  } else {
                      currentMode = 'chat-no-rag';
                      ragToggle.checked = false;
                  }
                  currentModeDisplay.textContent = currentMode;
                  updateSidebarDocVisibility(currentMode);

              } catch (error) {
                  console.error("Failed to load session history:", error);
                  addMessage('assistant', `**Error:** Failed to load session ${sessionId}.`);
              }
          }

          async function fetchDocuments() {
              if (!documentList) {
                console.error("fetchDocuments: documentList element not found.");
                return;
              }
              try {
                const response = await fetch('/v1/documents'); // This now only gets GLOBAL docs
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();
                documentList.innerHTML = '';

                if (result.documents && result.documents.length > 0) {
                  result.documents.forEach(doc => {
                    const li = document.createElement('li');
                    li.className = 'sidebar-item document-item';
                    li.textContent = `[${doc.chunk_count}] ${doc.parent_source}`;
                    li.title = `Source: ${doc.parent_source}\nChunks: ${doc.chunk_count}\nSpace: ${doc.data_space}`;
                    documentList.appendChild(li);
                  });
                } else {
                  documentList.innerHTML = '<li class="sidebar-no-item">No global documents</li>';
                }
              } catch (error) {
                console.error("Failed to fetch global documents:", error);
                documentList.innerHTML = '<li class="sidebar-item" style="color: var(--system-red);">Failed to load</li>';
              }
          }

          async function fetchLocalDocuments(sessionId) {
              if (!localDocList || !sessionId) {
                   localDocList.innerHTML = '<li class="sidebar-no-item">No local documents</li>';
                   return;
              }
              try {
                  const response = await fetch(`/v1/sessions/${sessionId}/documents`); // Task 3.4
                  if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                  const result = await response.json();
                  localDocList.innerHTML = '';

                  if (result.documents && result.documents.length > 0) {
                      result.documents.forEach(doc => {
                          const li = document.createElement('li');
                          li.className = 'sidebar-item document-item';
                          li.textContent = `[${doc.chunk_count}] ${doc.parent_source}`;
                          li.title = `Source: ${doc.parent_source}\nChunks: ${doc.chunk_count}`;
                          localDocList.appendChild(li);
                      });
                  } else {
                      localDocList.innerHTML = '<li class="sidebar-no-item">No local documents</li>';
                  }
              } catch (error) {
                  console.error("Failed to fetch local documents:", error);
                  localDocList.innerHTML = '<li class="sidebar-item" style="color: var(--system-red);">Failed to load</li>';
              }
          }

          function updateSidebarDocVisibility(mode) {
              if (mode.includes('no-rag')) {
                  // In "No RAG" mode, hide BOTH document lists
                  if (localDocumentsGroup) localDocumentsGroup.style.display = 'none';
                  if (globalDocumentsGroup) globalDocumentsGroup.style.display = 'none';
              } else {
                  // In "RAG" mode, show BOTH document lists
                  if (localDocumentsGroup) localDocumentsGroup.style.display = 'flex';
                  if (globalDocumentsGroup) globalDocumentsGroup.style.display = 'flex';
              }
          }

          function updateMessageLog() {
              messageLog.innerHTML = '';
              // Show history for the active session, or the welcome for the current mode
              const history = chatHistories[globalSessionId] || chatHistories[currentMode];
              if (history) {
                  history.forEach(msg => {
                      // Don't render "approval" cards from history
                      if (msg.type !== 'approval') {
                          addMessage(msg.role, msg.content, msg.sources);
                      }
                  });
              }
              scrollToBottom();
          }

          function addMessage(role, content, sources = []) {
              const messageDiv = document.createElement('div');
              messageDiv.className = `message ${role}`;
              const iconName = (role === 'user') ? 'user' : 'brain-circuit';
              const authorName = (role === 'user') ? 'You' : 'Aleutian AI';

              let renderedContent = md.render(content || ""); // Handle null/undefined content

              let sourcesHTML = '';
              if (sources && sources.length > 0) {
                sourcesHTML = '<div class="sources-box"><h4>Sources</h4><ul class="sources-list">';
                sources.forEach(source => {
                  let score = source.score ? `(Score: ${source.score.toFixed(3)})` : (source.distance ? `(Dist: ${source.distance.toFixed(3)})` : '');
                  sourcesHTML += `<li class="source-item">${source.source} ${score}</li>`;
                });
                sourcesHTML += '</ul></div>';
              }

              messageDiv.innerHTML = `
                  <div class="message-icon"><i data-lucide="${iconName}"></i></div>
                  <div class="message-content">
                      <strong>${authorName}</strong>
                      ${renderedContent}
                      ${sourcesHTML}
                  </div>`;
              messageLog.appendChild(messageDiv);
              lucide.createIcons();
              scrollToBottom();
          }

          function addApprovalCard(path, findings) {
              const messageDiv = document.createElement('div');
              messageDiv.className = 'message assistant';

              let findingsHTML = '<p>No issues found. Ready to ingest.</p>';
              if (findings && findings.length > 0) {
                findingsHTML = `<p>${findings.length} issue(s) found:</p><pre><code>`;
                findings.forEach(f => {
                  // Use finding struct fields from websocket.go
                  findingsHTML += `[L${f.line_number}] ${f.classification_name}: ${f.matched_content.substring(0, 50)}...\n`;
                });
                findingsHTML += `</code></pre>`;
              }

              messageDiv.innerHTML = `
                  <div class="message-icon"><i data-lucide="shield-alert"></i></div>
                  <div class="message-content">
                      <div class="approval-card">
                          <h4>Scan Results for <code>${path}</code></h4>
                          ${findingsHTML}
                          <div class="approval-buttons">
                              <button class="approve-btn" data-decision="approve-session" data-path="${path}">
                                  <i data-lucide="check" style="width:14px; height:14px;"></i> Approve (This Session)
                              </button>
                              <button class="approve-btn" style="background-color: var(--brand-default);" data-decision="approve-global" data-path="${path}">
                                  <i data-lucide="globe" style="width:14px; height:14px;"></i> Approve (Global)
                              </button>
                              <button class="deny-btn" data-decision="deny" data-path="${path}">
                                  <i data-lucide="x-circle" style="width:14px; height:14px;"></i> Deny
                              </button>
                          </div>
                      </div>
                  </div>`;
              messageLog.appendChild(messageDiv);
              lucide.createIcons();
              scrollToBottom();
          }

          function downloadChatHistory() {
              if (!globalSessionId || !chatHistories[globalSessionId]) {
                  alert("No active session history to download.");
                  return;
              }

              // 1. Get the history for the current session
              const history = chatHistories[globalSessionId];

              // 2. Convert it to a formatted JSON string
              const jsonString = JSON.stringify(history, null, 2);

              // 3. Create a blob
              const blob = new Blob([jsonString], { type: 'application/json' });

              // 4. Create a temporary URL for the blob
              const url = URL.createObjectURL(blob);

              // 5. Create a hidden 'a' tag to trigger the download
              const a = document.createElement('a');
              a.href = url;
              a.download = `aleutian_chat_${globalSessionId}.json`; // Set the filename

              // 6. Trigger the download
              document.body.appendChild(a);
              a.click();

              // 7. Clean up
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
          }

          function scrollToBottom() {
              messageLog.scrollTop = messageLog.scrollHeight;
          }

          // --- 7. Start the application ---
          sendButton.disabled = true;
          chatInput.disabled = true;
          currentModeDisplay.textContent = currentMode;
          connect();
      });
    </script>
</body>
</html>